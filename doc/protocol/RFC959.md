# 文件传输协议(FTP)

## 概述

### 术语

- `ASCII`：`ASCII`字符集的定义见`ARPA-Internet`。在`FTP`中，`ASCII`字符被定义为8位代码集的低7位(0~127)。
- `End-of-Line`：`End-of-Line`定义了打印行的分隔。先是回车（`\r`），然后是换行（`\n`）。
- `EOF`：定义要传输的文件结束的文件结束标识。
- `EOR`：定义要传输的记录的结束的标识。
- 字节大小（`byte size`）：FTP中有两种字节大小：文件的逻辑字节大小和用于传输数据的传输字节大小。传输字节大小始终为8位。传输字节大小不一定是数据在系统中存储的字节大小，也不一定是用于解释数据结构的逻辑字节大小。
- 访问控制（`access controls`）：访问控制定义了用户对系统使用和该系统中文件的访问权限。访问控制对于防止未经授权或意外使用文件是必要的。调用访问控制是服务器FTP进程的特权。
- `NVT`：`Telnet`协议中定义的网络虚拟终端。
- `NVFS`：网络虚拟文件系统。使用标准命令和路径名约定定义标准网络文件系统的概念。
- 路径名（`pathname`）：路径名被定义为字符串，用户必须将其输入到文件系统中才能识别文件。路径名通常包含设备和/或目录名以及文件名规范。`FTP`尚未指定标准路径名约定。每个用户都必须遵循传输中涉及的文件系统的文件命名约定。
- 控制连接（`control connection`）：`USER-PI`和`SERVER-PI`之间用于交换命令和回复的通信路径。此连接遵循Telnet协议。
- 数据连接（`data connection`）：指定模式（`mode`）和类型（`type`）传输数据的全双工连接。传输的数据可以是文件的一部分、整个文件或多个文件。这个连接可以在`SERVER-DTP`和用户`USER-DTP`之间，也可以在`SERVER-DTP`和`SERVER-DTP`之间。
- 数据端口（`data port`）：被动数据传输进程在数据端口上“监听”来自主动传输进程的连接，以打开数据连接。
- 错误恢复（`error recovery`）：允许用户从某些错误（如主机系统或传输进程的故障）中恢复的过程。在FTP中，错误恢复可能涉及在给定的检查点重新启动文件传输。
- `FTP`命令（`FTP commands`）：一组命令，包含从`USER-FTP`流向`SERVER-FTP`进程的控制信息。
- 回复（`reply`）：回复是服务器通过控制连接向用户发送的确认（肯定或否定），以响应`FTP`命令。回复的一般形式是完成代码（包括错误代码）后跟文本字符串。代码供程序使用，文本通常供人类用户使用。
- 文件（`file`）：一组有序的计算机数据（包括程序），具有任意长度，由路径名唯一标识。
- 页（`page`）：文件可以结构化为一组称为页面的独立部分。`FTP`支持将不连续文件作为独立的索引页面进行传输。
- 记录（`record`）：文件可以被结构化为多个称为记录的连续部分。`FTP`支持记录结构，但文件不需要具有记录结构。
- 模式（`mode`）：通过数据连接传输数据的模式。模式定义传输期间的数据格式，包括`EOR`和`EOF`。`FTP`中定义的传输模式在传输模式一节中进行了描述。
- 类型（`type`）：用于数据传输和存储的数据表示类型。类型意味着数据存储和数据传输之间的某些转换。`FTP`中定义的表示类型在“建立”一节中进行了描述
  数据连接。
- `DTP`：数据传输过程建立和管理数据连接。`DTP`可以是被动的或主动的。
- `PI`：协议解释器。协议的用户和服务器端分别有`USER-PI`和`SERVER-PI`不同的实现。
- `SERVER-FTP`进程（`SERVER-FTP process`）：一个或一组进程，与`USER-FTP`进程或者另一个`SERVER-FTP`进程协作，执行文件传输功能。功能由协议解释器（`PI`）和数据传输过程（`DTP`）组成。
- `SERVER-DTP`：数据传输过程在其正常“主动（`active`）”状态下，与“侦听”数据端口建立数据连接。它设置传输和存储参数，并根据来自其PI的命令传输数据。`DTP`可以置于“被动（`passive`）”状态以侦听，而不是在数据端口上启动连接。
- `SERVER-PI`：服务器协议解释器在端口`L`上“侦听”来自`USER-PI`的连接，并建立控制通信连接。它从`USER-PI`接收标准`FTP`命令，发送回复，并管理`SERVER-DTP`。
- 用户（`user`）：代表希望获得文件传输服务的人或流程。人类用户可以直接与`SERVER-FTP`进程交互，但首选使用`USER-FTP`进程，因为协议设计倾向于自动机。
- `USER-FTP` 进程（`USER-FTP process`）：一组功能，包括协议解释器、数据传输进程和用户界面，这些功能与一个或多个`SERVER-FTP`进程一起执行文件传输功能。用户界面允许在与用户的命令回复对话中使用本地语言。
- `USER-DTP`：数据传输进程在数据端口上“侦听”来自`SERVER-FTP`进程的连接。如果两个服务器正在它们之间传输数据，则`USER-DTP`处于非活动状态。
- `USER-PI`：用户协议解释器启动从其端口`U`到`SERVER-FTP`进程的控制连接，启动`FTP`命令，并管理`USER-DTP`（如果该进程是文件传输的一部分）。

### FTP 模型

#### FTP使用模型

```MODEL
                                            -------------
                                            |/---------\|
                                            ||   User  ||    --------
                                            ||Interface|<--->| User |
                                            |\----^----/|    --------
                  ----------                |     |     |
                  |/------\|  FTP Commands  |/----V----\|
                  ||Server|<---------------->|   User  ||
                  ||  PI  ||   FTP Replies  ||    PI   ||
                  |\--^---/|                |\----^----/|
                  |   |    |                |     |     |
      --------    |/--V---\|      Data      |/----V----\|    --------
      | File |<--->|Server|<---------------->|  User   |<--->| File |
      |System|    || DTP  ||   Connection   ||   DTP   ||    |System|
      --------    |\------/|                |\---------/|    --------
                  ----------                -------------

                  Server-FTP                   USER-FTP
```

> 注：
>
> 1. 数据连接（`Data Connection`）可以在任何方向上使用。
> 2. 数据连接（`Data Connection`）不需要一直存在。

​	如上图所示，用户协议解释器发起控制连接。控制连接遵循`Telnet`协议。在用户启动时，标准`FTP`命令由`USER-PI`生成，并通过控制连接传输到服务器进程。（例如，用户可以从`TAC`^[1]^终端建立到`SERVER-FTP`的直接控制连接，并独立生成标准`FTP`命令，绕过`USER-FTP`进程。）标准回复响应于命令，通过控制连接从`SERVER-PI`发送到`USER-PI`。

​	`FTP`命令指定数据连接的参数（数据端口、传输模式、表示类型和结构）和文件系统操作的性质（存储、检索、追加、删除等）。`USER-DTP`或其指定人员应“侦听”指定的数据端口，服务器根据指定的参数启动数据连接和数据传输。应该注意的是，数据端口不需要在通过控制连接启动`FTP`命令的同一主机上，但用户或`USER-FTP`进程必须确保在指定的数据端口上“侦听”。还应该注意，数据连接可以用于同时发送和接收。

​	在另一种情况下，用户可能希望在两个主机之间传输文件，这两个主机都不是本地主机。用户设置到两个服务器的控制连接，然后安排它们之间的数据连接。以这种方式，通过`USER-PI`传递控制信息，但数据在服务器数据传输过程之间传输。下面是这种服务器-服务器交互的模型。

```MODEL
                    Control     ------------   Control
                    ---------->| User-FTP |<-----------
                    |          | User-PI  |           |
                    |          |   "C"    |           |
                    V          ------------           V
            --------------                        --------------
            | Server-FTP |   Data Connection      | Server-FTP |
            |    "A"     |<---------------------->|    "B"     |
            -------------- Port (A)      Port (B) --------------
```

​	协议要求在数据传输过程中打开控制连接。用户有责任在使用完`FTP`服务后请求关闭控制连接，而由服务器执行操作。如果在没有命令的情况下关闭控制连接，服务器可能会中止数据传输。

> `FTP`和`Telnet`之间的关系：
>
> ​	`FTP`在控制连接上使用`Telnet`协议。这可以通过两种方式实现：`USER-PI`或`SERVER-PI`可以在自己的过程中直接实现`Telnet`协议的规则；或者`USER-PI`或`SERVER-PI`可以使用系统中的现有`Telnet`模块。
>
> ​	易于实现、共享代码和模块化编程支持第二种方法。效率和独立性支持第一种方法。在实践中，FTP很少依赖Telnet协议，因为第一种方法不一定涉及大量代码。

## 数据传输功能

​	文件仅通过数据连接传输。控制连接用于传输命令，该命令描述要执行的功能以及对这些命令的答复（请参阅`FTP`答复部分）。有几个命令与主机之间的数据传输有关。这些数据传输命令包括指定如何传输数据位的`MODE`命令，以及用于定义数据表示方式的`STRUcture`和`TYPE`命令。传输和表示基本上是独立的，但“流”传输模式取决于文件结构属性，如果使用“压缩”传输模式，填充字节的性质取决于表示类型。

### 数据表示和存储

​	数据从发送主机中的存储设备传输到接收主机中的存储器设备。通常需要对数据执行某些转换，因为两个系统中的数据存储表示形式不同。例如，`NVT-ASCII`在不同的系统中具有不同的数据存储表示。`DEC TOPS-20s`通常将`NVT-ASCII`存储为五个7位`ASCII`字符，在36位字中左对齐。`IBM`大型机将`NVT-ASCII`存储为8位`EBCDIC`代码。多播将`NVT-ASCII`存储为36位字中的四个9位字符。在不同系统之间传输文本时，希望将字符转换为标准`NVT-ASCII`表示。发送和接收站点必须在标准表示及其内部表示之间执行必要的转换。（可以百度百科一下编码与编码格式加强理解 😁）

​	在具有不同字长的主机系统之间传输二进制数据（而不是字符代码）时，会出现表示上的不同问题。并不总是清楚发送方应如何发送数据，而接收方应如何存储数据。例如，当将32位字节从32位字长系统传输到36位字长系统时，（出于效率和有用性的原因）可能希望在后一个系统中存储在36位字中右对齐的32位字节。在任何情况下，用户都应该可以选择指定数据表示和转换函数。应该注意，`FTP`提供的数据类型表示非常有限。超出此有限功能的所需转换应由用户直接执行。

#### 数据类型

​	在`FTP`中，通过一个用户指定的数据表示类型来处理对应的数据。这种类型可以隐式（如`ASCII`或`EBCDIC`）或显式（如本地字节）定义用于解释的字节大小，称为“逻辑字节大小”。请注意，这与用于通过数据连接传输的字节大小（称为“传输字节大小”）无关，不应混淆这两者。例如，`NVT-ASCII`具有8位的逻辑字节大小。如果类型是本地字节，则`type`命令具有指定逻辑字节大小的必需第二个参数。传输字节大小始终为8位。

##### `ASCII` 类型

​	这是默认类型，必须被所有`FTP`实现接受。它主要用于传输文本文件，除非两个主机都认为`EBCDIC`类型更方便。

​	发送方将数据从内部字符表示转换为标准的8位`NVT-ASCII`表示（请参阅`Telnet`规范）。接收方将数据从标准格式转换为自己的内部格式。

​	根据`NVT`标准，必要时应使用`<CRLF>`序列来表示文本行的结束。（请参阅“数据表示和存储”一节末尾的文件结构讨论。）

​	使用标准NVT-ASCII表示意味着数据必须解释为8位字节。

​	下面讨论ASCII和EBCDIC类型的Format参数。

##### `EBCDIC` 类型

​	这种类型用于在使用`EBCDIC`作为其内部字符表示的主机之间进行有效传输。

​	对于传输，数据表示为8位`EBCDIC`字符。字符代码是`EBCDIC`和`ASCII`类型的功能规范之间的唯一区别。

​	`End-of-line` (as opposed to end-of-record--see the discussion of structure) will probably be rarely used with EBCDIC type for purposes of denoting structure, but where it is necessary the `<NL>` character should be used.

##### `IMAGE` 类型

​	数据作为连续比特发送，为了传输，这些比特被打包到8位传输字节中。接收站点必须将数据存储为连续位。存储系统的结构可能需要将文件（或记录结构化文件的每个记录）填充到某个方便的边界（字节、字或块）。该填充（必须全部为零）只能出现在文件的末尾（或每个记录的末尾），并且必须有一种识别填充位的方法，以便在检索文件时可以去除它们。应该很好地宣传填充转换，以使用户能够在存储站点处理文件。

​	`IMAGE`类型用于文件的有效存储和检索以及二进制数据的传输。建议所有`FTP`实现都接受此类型。

##### `LOCAL` 类型

​	数据以逻辑字节的形式传输，逻辑字节的大小由必需的第二个参数Byte size指定。字节大小的值必须是十进制整数；没有默认值。逻辑字节大小不一定与传输字节大小相同。如果字节大小不同，则逻辑字节应连续打包，而不考虑传输字节边界以及在末尾使用任何必要的填充。

​	当数据到达接收主机时，它将以取决于逻辑字节大小和特定主机的方式进行转换。该转换必须是可逆的（即，如果使用相同的参数，则可以检索相同的文件），并且应该由FTP实现者很好地公开。

​	**例如，向具有32位字的主机发送36位浮点数的用户可以将该数据作为逻辑字节大小为36的本地字节发送。然后，接收主机将被期望存储逻辑字节，以便它们可以容易地被操作；在这个例子中，将36位逻辑字节放入64位双字应该足够了。**

​	在另一个示例中，具有36位字大小的一对主机可以通过使用类型L 36以字的形式彼此发送数据。数据将以8位传输字节的形式发送，以使9个传输字节携带两个主机字。

##### 格式控制（`FORMAT CONTROL`）

​	`ASCII`和`EBCDIC`类型也采用第二个（可选）参数；这是为了指示哪种垂直格式控制（如果有）与文件相关联。`FTP`中定义了以下数据表示类型：

​	字符文件可以传输到主机，用于三个目的之一：用于打印、存储和以后检索，或用于处理。如果发送文件进行打印，则接收主机必须知道垂直格式控件的表示方式。在第二种情况下，必须可以在主机上存储文件，然后以完全相同的形式稍后检索它。最后，应该可以将文件从一个主机移动到另一个主机，并在第二个主机上处理该文件，而不会产生不必要的麻烦。单个`ASCII`或`EBCDIC`格式不能满足所有这些条件。因此，这些类型具有第二个参数，指定以下三种格式之一：

- **非打印格式（`NON PRINT`）**

  ​	这是省略第二个（格式）参数时使用的默认格式。所有FTP实现都必须接受非打印格式。文件不需要包含垂直格式信息。如果将其传递给打印机进程，则该进程可以采用间距和边距的标准值。通常，此格式将用于指定用于审阅或仅用于存储的文件。

- **TELNET格式控制（`TELNET FORMAT CONTROLS`）**

  ​	该文件包含`ASCII`/`EBCDIC`垂直格式控件（即，`<CR>`、`<LF>`、`<NL>`、`<VT>`、`<FF>`），打印机进程将适当解释这些控件。`<CRLF>`，在这个序列中，也表示行尾。

- **`CARRIAGE CONTROL (ASA)`**

  ​	该文件包含`ASA`（`FORTRAN`）垂直格式控制字符。（See RFC 740 Appendix C; and Communications of the ACM, Vol. 7, No. 10, p. 606, October 1964.）在根据`ASA`标准格式化的行或记录中，不打印第一个字符。相反，它应该用于确定纸张的垂直移动，该移动应该在打印记录的其余部分之前发生。`ASA`标准规定了以下控制字符：

  - 空白符（`blank`）：将纸张上移一行
  - `0`：将纸张向上移动两行
  - `1`：将纸张移至下一页顶部
  - `+`：不移动

  显然，打印机进程必须有某种方法来区分结构实体的末尾。如果文件具有记录结构（见下文），这不是问题；在传输和存储期间，将显式标记记录。如果文件没有记录结构，则`<CRLF>`行尾序列用于分隔打印行，但这些格式控制符被`ASA`控件覆盖。

#### 数据结构（`DATA STRUCTURES`）

​	除了不同的表示类型外，`FTP`还允许指定文件的结构。`FTP`中定义了三种文件结构：

| 文件结构           | 说明                                             |
| ------------------ | ------------------------------------------------ |
| `file-structure`   | 没有内部结构，并且文件被认为是数据字节的连续序列 |
| `record-structure` | 文件由有序的记录组成                             |
| `page-structure`   | 文件由独立的索引页组成                           |

​	如果未使用`STRUcture`命令，则默认假定为`file-structure`，但所有`FTP`实现都必须实现类型（`TYPE`）为`ASCII`或者`EBCDIC`的`file-structure`和`record-structure`文件结构。文件的结构将影响文件的传输模式（见传输模式一节）以及文件的解释和存储。

​	文件的“自然”结构将依赖于存储文件的主机。源代码文件以固定长度的记录存储在`IBM`大型机上，以字符流存储在`DEC TOPS-20`上，由`<CRLF>`划分为行。如果在这种不同的站点之间传输文件是有效的（经过传输后内容不变化），那么一个站点必须有某种方法来识别另一个站点对文件的假设。

​	由于某些站点自然是面向文件的，而其他站点自然是基于记录的，因此如果将具有一种结构的文件发送到面向另一种结构主机，则可能会出现问题。如果将具有记录结构的文本文件发送到面向文件的主机，则该主机应基于记录结构对文件应用内部转换。显然，这种转换应该是有用的，但它也必须是可逆的，以便可以使用记录结构检索相同的文件。

​	在将具有`file-structure`的文件发送到面向记录的主机的情况下，存在一个问题，即主机应该使用什么标准来将文件划分为可以在本地处理的记录。如果需要进行此划分，`FTP`实现应使用`end-of-line`，`ASCII`的`<CRLF>`或`EBCDIC`的`<NL>`作为分隔符。如果`FTP`实现采用此技术，则必须准备在使用`file-structure`检索文件时反转转换。

##### 文件结构（`FILE STRUCTURE`）

​	如果未使用`STRUcture`命令，则默认假定为`file-structure`。在文件结构（`file-structure`）中没有内部结构，文件被认为是连续的数据字节序列。

> 来一段车轱辘话：文件结构是文件结构类型之一😄

##### 记录结构（`RECORD STRUCTURE`）

​	所有`FTP`实现都必须接受“文本”文件（即具有类型为`ASCII`或`EBCDIC`的文件）的记录结构（`record-structure`）。在`record-structure`中，文件由顺序记录组成。

##### 页结构（`PAGE STRUCTURE`）

​	为了传输不连续的文件，`FTP`定义了页面结构（`page-structure`）。这种类型的文件有时称为“随机访问文件”，也可以称为“多孔文件”。在这些文件中，有时存在与文件整体（例如，文件说明）或文件的一部分（例如，页面访问控制）或两者相关的其他信息。在FTP中，文件的部分称为页面。

> 可以参考微软的WORD文档

​	为了提供各种页面大小和相关信息，每个页面（`page`）都与页眉（`page Header`）一起发送。页眉具有以下定义的字段：

- `Header Length`：标头长度最小为4，用来表示页中标头的逻辑字节数
- `Page Index`：这是用于标记该页在文件中的位置
- `Data Length`：最小为0，用来表示页中数据的逻辑字节数
- `Page Type`：页类型被定义如下：
  - `0 = Last Page`：这用于指示分页结构化传输的结束。标头长度必须为4，数据长度必须为0。
  - `1 = Simple Page`：这是没有页面级关联控制信息的简单分页文件的正常类型。标头长度必须为4。
  - `2 = Descriptor Page`：该类型用于传输整个文件的描述性信息。
  - `3 = Access Controlled Page`：此类型包括具有页面级访问控制信息的分页文件的附加标题字段。标头长度必须为5。
- `Optional Fields`：还可以使用标题字段来提供每页控制信息，例如，每页访问控制。

​	所有字段的长度都是一个逻辑字节。逻辑字节大小由`TYPE`命令指定。有关更多详细信息和页面结构中的特定案例，请参见附录I。

> 关于参数的注意事项：如果检索的版本要与最初传输的版本相同，则必须使用相同的参数存储和检索文件。相反，如果用于存储和检索文件的参数相同，则FTP实现必须返回与原始文件相同的文件。

### 建立数据连接（`ESTABLISHING DATA CONNECTIONS`）

​	传输数据的机制包括建立到适当端口的数据连接，并选择用于传输的参数。用户和服务器DTP都有默认数据端口。用户进程默认数据端口与控制连接端口（即U）相同。服务器进程默认数据端口是与控制连接端口相邻的端口（即L-1）。

​	传输字节大小为8位字节。该字节大小仅与数据的实际传输相关；它与主机文件系统中的数据表示无关。

​	被动数据传输过程（这可以是`USER-DTP`或第二个`SERVER-DTP`）应在发送传输请求命令之前在数据端口上“侦听”。`FTP`请求命令确定数据传输的方向。服务器在接收到传输请求时，将启动到端口的数据连接。当连接建立时，`DTP`之间的数据传输开始，`SERVER-PI`向`USER-PI`发送确认回复。

​	每个`FTP`实现都必须支持使用默认数据端口，并且只有`USER-PI`可以启动对非默认端口的更改。

​	用户可以使用`PORT`命令指定备用数据端口。用户可能希望将文件转储到`TAC`行打印机上或从第三方主机检索。在后一种情况下，`USER-PI`与两个`SERVER-PI`建立控制连接。然后（通过`FTP`命令）告诉一个服务器“侦听”另一个服务器将启动的连接。`USER-PI`向一个`SERVER-PI`发送指示另一个服务器的数据端口的`PORT`命令。最后，向两者发送适当的传输命令。在用户控制器和服务器之间发送的命令和回复的确切顺序在`FTP`回复部分中定义。

​	通常，服务器负责维护数据连接——启动并关闭它。例外情况是，当`USER-DTP`以传输模式发送数据时，该模式要求关闭连接以指示`EOF`。在以下情况下，服务器必须关闭数据连接：

1. 服务器已在需要关闭以指示`EOF`的传输模式下完成数据发送。
2. 服务器从用户接收`ABORT`命令。
3. 端口号由用户的命令更改。
4. 控制连接合法关闭或以其他方式关闭。
5. 发生不可恢复的错误情况。

> 总结：除了`USER-DTP`发送数据完成后由`USER-FTP`自己关闭连接外，其他情况都由`SERVER-FTP`关闭连接。

### 数据连接管理（`DATA CONNECTION MANAGEMENT`）

​	默认数据连接端口：所有`FTP`实现都必须支持使用默认的数据连接端口，并且只有`USER-PI`可以启动非默认端口的使用。

​	协商非默认数据端口：`USER-PI`可以使用`PORT`命令指定非默认用户端数据端口。`USER-PI`可以使用`PASV`命令请求服务器端提供非默认服务器端数据端口。由于连接由地址对定义，因此这些操作中的任何一个都足以获得不同的数据连接，但仍然允许执行这两个命令，以在数据连接的两端使用新端口。

​	数据连接的重用：当使用数据传输的流模式时，必须通过关闭连接来指示文件的结束。如果要在会话中传输多个文件，这会导致问题，因为`TCP`需要将连接记录保留一段超时时间，以保证可靠的通信。因此，无法立即重新打开连接。

​	这个问题有两种解决方案。第一个是协商非默认端口。第二个是使用另一种传输模式。

​	关于传输模式的解释。流传输模式本质上是不可靠的，因为无法确定连接是否过早关闭。其他传输模式（块、压缩）不会关闭连接以指示文件结束。它们具有足够的`FTP`编码，可以解析数据连接以确定文件的结尾。因此，使用这些模式，可以使数据连接为多个文件传输打开。

### 传输模式（`TRANSMISSION MODES`）

​	传输数据时的下一个考虑事项是选择适当的传输模式。有三种模式：一种是格式化数据并允许重新启动过程；还压缩数据以进行有效传输的一种；以及在很少或没有处理的情况下传递数据的方法。在最后一种情况下，模式与结构属性交互以确定处理类型。在压缩模式下，表示类型确定填充字节。

​	所有数据传输必须以文件尾（`EOF`）完成，文件尾可以通过关闭数据连接来明确说明或暗示。对于具有记录结构的文件，所有记录结束标记（`EOR`）都是显式的，包括最后一个。对于以页面结构传输的文件，使用“最后一页”页面类型。

> 注：在本节的其余部分中，字节是指“传输字节”，除非另有明确规定。

​	为了实现标准化传输，发送主机将其内部行尾或记录尾表示转换为传输模式和文件结构规定的表示，接收主机将对其内部表示执行反向转换。`IBM`大型机记录计数字段可能在另一台主机上无法识别，因此记录结束信息可以在流模式下作为双字节控制代码传输，也可以在块或压缩模式描述符中作为标记位传输。`ASCII`或`EBCDIC`文件中没有记录结构的行尾应分别用`<CRLF>`或`<NL>`表示。由于这些转换意味着某些系统需要额外的工作，传输非记录结构（`record-structure`）化文本文件的相同系统可能希望使用二进制表示和流模式进行传输。

> 主机内部数据--转换成`file-structure`和特定的传输模式<--网络-->转化成对端主机的内部表示类型以及文件结构-->存储在文件系统中

#### 流模式（`STREAM MODE`）

​	数据以字节流的形式传输。对使用的表示类型没有限制；允许记录结构。

​	在记录结构（`record-structure`）化文件中，`EOR`和`EOF`将分别由两个字节的控制代码表示。控制代码的第一个字节的所有位置1，即转义符。第二个字节的`EOR`值为1，`EOF`值为2。`EOR`和`EOF`可以通过打开这两个低位（即值3）在传输的最后一个字节上一起指示。如果转义符打算作为数据发送，则应在控制代码的第二个字节中重复该字节。

> 假设逻辑字节为8位，传输的数据中有一个数据为`0xff`，应该转换为`0xffff`再传输！！！

如果结构是文件结构，则`EOF`由关闭数据连接的发送主机指示，并且所有字节都是数据字节。

#### 块模式（`BLOCK MODE`）

​	文件作为一系列数据块传输，数据块前面有一个或多个报头字节。头字节包含计数字段和描述符代码。计数字段以字节为单位指示数据块的总长度，从而标记下一个数据块的开始（没有填充位）。描述符代码定义：文件中的最后一个块（`EOF`）记录中的最后几个块（`EOR`）、重新启动标记（请参阅错误恢复和重新启动一节）或可疑数据（即，正在传输的数据可能有错误，并且不可靠）。最后一个代码不用于`FTP`中的错误控制。它的动机是交换某些类型的数据（例如，地震或天气数据）的站点希望发送和接收所有数据，尽管存在本地错误（例如“磁带读取错误”），但在传输中指示某些部分是可疑的）。在此模式下允许记录结构，并且可以使用任何表示类型。

​	标头由三个字节组成。在24位报头信息中，16个低位应表示字节计数，8个高位应表示描述符代码，如下所示。

```m
Block Header

            +----------------+----------------+----------------+
            | Descriptor     |    Byte Count                   |
            |         8 bits |                      16 bits    |
            +----------------+----------------+----------------+
```

​	描述符代码由描述符字节中的位标志指示。分配了四个代码，其中每个代码号是字节中相应位的十进制值。

| 代码 | 含义                              |
| ---- | --------------------------------- |
| 128  | 数据块结束为`EOR`（用于记录结构） |
| 64   | 数据块末尾为`EOF`（用于文件结构） |
| 32   | 数据块中的可疑错误                |
| 16   | 数据块是重新启动标记              |

​	通过这种编码，对于特定块可以存在多个描述符编码条件。可以标记所需的尽可能多的位。

The restart marker is embedded in the data stream as an integral number of 8-bit bytes representing printable characters in the language being used over the control connection (e.g., default--NVT-ASCII).  <SP> (Space, in the appropriate language) must not be used WITHIN a restart marker.（后续翻译！！！）

例如，要传输六个字符的标记，将发送以下内容：

```m
            +--------+--------+--------+
            |Descrptr|  Byte count     |
            |code= 16|             = 6 |
            +--------+--------+--------+

            +--------+--------+--------+
            | Marker | Marker | Marker |
            | 8 bits | 8 bits | 8 bits |
            +--------+--------+--------+

            +--------+--------+--------+
            | Marker | Marker | Marker |
            | 8 bits | 8 bits | 8 bits |
            +--------+--------+--------+
```

#### 压缩模式（`COMPRESSED MODE`）

​	有三种类型的信息要发送：常规数据，以字节字符串形式发送；压缩数据，由复制或填充组成；和控制信息，以双字节转义序列发送。如果发送`n>0`个字节（最多127个）的常规数据，则在这`n`个字节之前有一个字节，最左边的位设置为0，最右边的7个位包含数字`n`。

```m
    Byte string:

             1       7                8                     8
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
            |0|       n     | |    d(1)       | ... |      d(n)     |
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
                                          ^             ^
                                          |---n bytes---|
                                              of data
        String of n data bytes d(1),..., d(n)
		Count n must be positive.
```

​	要压缩数据字节`d`的`n`个副本的字符串，发送以下2个字节：

```m
         Replicated Byte:

              2       6               8
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
            |1 0|     n     | |       d       |
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
```

可以将`n`个填充字节的字符串压缩为单个字节，其中填充字节随表示类型而变化。如果类型为`ASCII`或`EBCDIC`，则填充字节为`<SP>`（空格，`ASCII`代码32，`EBCDIC`代码64）。如果类型为`Image`或`Local` 类型，则填充符为零字节。

```m
         Filler String:

              2       6
            +-+-+-+-+-+-+-+-+
            |1 1|     n     |
            +-+-+-+-+-+-+-+-+
```

​	转义序列是双字节，第一个是转义字节（全零），第二个包含块模式中定义的描述符代码。描述符代码具有与块模式中相同的含义，并应用于后续的字节串。

​	压缩模式对于稍微增加一点`CPU`成本从而获得网络中更大的带宽是有用的。它可以最有效地用于减少打印机文件的大小，如`RJE`主机生成的文件。

### 错误恢复和重传（`ERROR RECOVERY AND RESTART`）

​	没有用于检测数据传输中丢失或置乱的比特的规定；这种级别的错误控制由`TCP`处理。但是提供了重新启动过程来保护用户免受严重系统故障（包括主机、`FTP`进程或底层网络的故障）的影响。

> `TCP`也有极少数情况会出现传输错误的情况，对于后续设计可以增加一个应用数据校验:expressionless:

​	重新启动过程仅为数据传输的块和压缩模式定义。它要求数据的发送方在数据流中插入具有某些标记信息的特殊标记代码。标记信息仅对发送方有意义，但必须由控制连接的默认或协商语言（`ASCII`或`EBCDIC`）中的可打印字符组成。标记可以表示位计数、记录计数或系统可以用来标识数据检查点的任何其他信息。数据的接收器（如果它实现了重启过程）随后将在接收系统中标记该标记的相应位置，并将该信息返回给用户。

> 实际实现中会为流传输模式增加断点重传的功能：
>
> - **原理**：客户端在下载文件时，会先通过 `SIZE` 命令（RFC 3659）获取远程文件的大小。
> - **检查本地文件**：如果本地存在一个不完整的文件，客户端会检查其大小。
> - **使用 `REST` 命令**：客户端使用 `REST` 命令，参数为本地文件的当前大小（例如 `REST 204800`），告诉服务器：“请从文件的第204800字节处开始传输。”
> - **使用流模式下载**：客户端发起一个新的 `RETR` 命令。服务器收到 `REST` 后，会跳过指定的字节数，然后以**流模式**将文件的剩余部分发送给客户端。客户端则将接收到的数据**追加**到本地不完整文件的末尾。

​	在系统故障的情况下，用户可以通过使用FTP重新启动过程标识标记点来重新启动数据传输。下面的示例说明了重新启动过程的使用。

​	数据的发送器在数据流中的方便点插入适当的标记块。接收主机在其文件系统中标记相应的数据点，并在110回复中直接或通过控制连接将最后已知的发送方和接收方标记信息传送给用户（取决于谁是发送方）。在系统发生故障的情况下，用户或控制器进程通过发送重新启动命令，并将服务器的标记代码作为其参数，在最后一个服务器标记处重新启动服务器。重启命令通过控制连接传输，并紧跟在系统故障发生时正在执行的命令（如`RETR`、`STOR`或`LIST`）之后。

## 文件传输功能（`FILE TRANSFER FUNCTIONS`）

​	从`USER-PI`到`SERVER-PI`的通信信道被建立为从用户到标准服务器端口的`TCP`连接。`USER-PI`负责发送`FT`P命令和解释接收到的回复；`SERVER-PI`解释命令，发送回复，并指示其`DTP`建立数据连接和传输数据。如果数据传输的第二方（被动传输过程）是`USER-DTP`，则它通过用户`FTP`主机的内部协议进行管理；如果它是第二个`SERVER-DTP`，则它通过`USER-PI`管理。`FTP`回复将在下一节中讨论。在本节中的几个命令的描述中，明确说明可能的响应是有帮助的。

### `FTP`命令（`FTP COMMANDS`）

#### 访问控制命令（`ACCESS CONTROL COMMANDS`）

以下命令指定访问控制标识符（命令代码显示在括号中）。

- **`USER NAME (USER)`**

  ​	参数字段是标识用户的`Telnet`字符串。用户标识是服务器访问其文件系统所需的标识。此命令通常是用户在建立控制连接后发送的第一个命令（某些服务器可能需要此命令）。一些服务器也可能需要密码和/或帐户命令形式的附加标识信息。服务器可以允许在任何时候输入新的`USER`命令，以更改访问控制和/或计费信息。这会刷新已提供的任何用户、密码和帐户信息，并再次开始登录序列。所有传输参数不变，任何正在进行的文件传输都是在旧的访问控制参数下完成的。

- **`PASSWORD (PASS)`**

  ​	参数字段是指定用户密码的`Telnet`字符串。此命令必须紧跟在用户名命令之后，对于某些站点，它完成了用户的身份识别以进行访问控制。由于密码信息非常敏感，一般来说，最好“屏蔽”它或禁止打字。服务器似乎没有万无一失的方法来实现这一点。因此，`USER-FTP`进程有责任隐藏敏感的密码信息。

- **`ACCOUNT (ACCT)`**

  ​	参数字段是一个Telnet字符串，用于标识用户的帐户。该命令不一定与`USER`命令相关，因为一些站点可能需要一个帐户登录，而另一些站点仅需要特定的访问权限，如存储文件。在后一种情况下，命令可能随时到达。

  ​	有回复代码来区分自动化的这些情况：当登录需要帐户信息时，对成功的`PASSword`命令的响应是回复代码332。另一方面，如果登录不需要帐户信息，则对成功的密码命令的回复为230；如果对话中稍后发出的命令需要帐户信息，则服务器应分别返回332或532回复，具体取决于它是存储（等待接收`ACCount`命令）还是丢弃该命令。

  > 其实就是授权！！！比如能够访问哪些资源。

- **`CHANGE WORKING DIRECTORY (CWD)`**

  ​	此命令允许用户切换不同的工作目录或数据集来进行文件存储或检索，而无需更改其登录或会计信息。传输参数同样保持不变。参数是指定目录或其他依赖于系统的文件组指示符的路径名。

- **`CHANGE TO PARENT DIRECTORY (CDUP)`**

  ​	此命令是`CWD`的一个特例，用于简化在具有不同语法的操作系统之间传输目录树的程序的实现，以命名父目录。回复代码应与`CWD`的回复代码相同。详见附录二。

- **`STRUCTURE MOUNT (SMNT)`**

  ​	此命令允许用户装载不同的文件系统数据结构，而无需更改其登录或记帐信息。传输参数同样保持不变。参数是指定目录或其他依赖于系统的文件组指示符的路径名。

  > 挂载其他类型文件系统到现有的文件系统路径名下，不常用

- **`REINITIALIZE (REIN)`**

  ​	此命令终止`USER`，刷新所有`I/O`和帐户信息，但允许完成任何正在进行的传输除外。所有参数都重置为默认设置，控制连接保持打开状态。这与用户在控制连接打开后立即发现自己的状态相同。可能会出现`USER`命令。

- **`LOGOUT (QUIT)`**

  ​	此命令终止`USER`，如果文件传输未进行，服务器将关闭控制连接。如果正在进行文件传输，则连接将保持打开状态以等待结果响应，然后服务器将关闭它。如果用户进程正在为多个用户传输文件，但不希望关闭并重新打开每个用户的连接，则应使用`REIN`命令而不是`QUIT`。
  ​	控制连接上的意外关闭将导致服务器采取中止（`ABOR`）和注销（`QUIT`）的有效操作。

#### 传输参数命令（`TRANSFER PARAMETER COMMANDS`）

​	所有数据传输参数都有默认值，只有当要更改默认参数值时，才需要指定数据传输参数的命令。默认值是最后指定的值，或者如果没有指定值，则标准默认值如下所述。这意味着服务器必须“记住”适用的默认值。命令的顺序可以是任意的，但是它们必须位于FTP服务请求之前。以下命令指定数据传输参数：

- `DATA PORT (PORT)`

  ​	参数是数据连接中使用的数据端口的`HOST-PORT`规范。用户和服务器数据端口都有默认值，在正常情况下不需要此命令及其回复。如果使用此命令，则参数是32位互联网主机地址和16位`TCP`端口地址的连接。该地址信息被分解为8位字段，每个字段的值以十进制数（字符串表示）的形式传输。字段用逗号分隔。端口命令为：

  ```sh
  PORT h1,h2,h3,h4,p1,p2
  ```

  其中`h1`是互联网主机地址的高位8位。

- `PASSIVE (PASV)`

  ​	此命令请求`SERVER-DTP`在数据端口（不是其默认数据端口）上“监听”，并等待连接，而不是在收到传输命令后启动连接。对此命令的响应包括此服务器正在侦听的主机和端口地址。

- `REPRESENTATION TYPE (TYPE)`

  ​	该参数指定了数据表示和存储一节中描述的表示类型。有几种类型需要第二个参数。第一个参数由单个`Telnet`字符表示，`ASCII`和`EBCDIC`的第二个`Format`参数也是如此；本地字节的第二个参数是表示`Bytesize`的十进制整数。参数之间用`<SP>`（空格，`ASCII`码32）分隔（例如：`TYPE L 8`）。

  ​	为类型分配了以下代码：

  ```m
  语法：TYPE <A | E | I | L <Format>>
  
  代码：
  						 \    /
                 A - ASCII |    | N - Non-print
                           |-><-| T - Telnet format effectors
                 E - EBCDIC|    | C - Carriage Control (ASA)
                           /    \
                 I - Image
  
                 L <byte size> - Local byte Byte size
  ```

  ​	默认表示类型为`ASCII`非打印。如果更改了`Format`参数，然后只更改了第一个参数，`Format`将返回到非打印默认值。

- `FILE STRUCTURE (STRU)`

  ​	参数是一个`Telnet`字符代码，指定了数据表示和存储一节中描述的文件结构。为结构分配了以下代码：

  | 代码 | 含义               |
  | ---- | ------------------ |
  | `F`  | 文件（无记录结构） |
  | `R`  | 记录结构           |
  | `P`  | 页结构             |

  默认的结构是文件（`file-structure`）。

- `TRANSFER MODE (MODE)`

  ​	参数是一个`Telnet`字符代码，指定了传输模式一节中描述的数据传输模式。为传输模式分配了以下代码：

  | 代码 | 含义     |
  | ---- | -------- |
  | `S`  | 流模式   |
  | `B`  | 块模式   |
  | `C`  | 压缩模式 |

  默认模式是流模式。

#### `FTP`服务命令（`FTP SERVICE COMMANDS`）

​	`FTP`服务命令定义了用户请求的文件传输或文件系统功能。`FTP`服务命令的参数通常是路径名。路径名的语法必须符合服务器站点惯例（适用标准默认值），以及语法要符合控制连接的惯例。建议的默认处理是使用最后指定的设备、目录或文件名，或为本地用户定义的标准默认值。命令的顺序可以是任何顺序，但“重命名自”命令后面必须跟着“重命名至”命令，重启命令后面必须跟中断的服务命令（例如`STOR`或`RETR`）。响应`FTP`服务命令传输的数据应始终通过数据连接发送，但某些信息性回复除外。以下命令指定`FTP`服务请求：

- `RETRIEVE (RETR)`

  ​	此命令使`SERVER-DTP`将路径名中指定的文件副本传输到数据连接另一端的`SERVER-DTP`或`USER-DTP`。服务器站点的文件状态和内容不受影响。

- `STORE (STOR)`

  ​	此命令使`SERVER-DTP`接受通过数据连接传输的数据，并将数据作为文件存储在服务器站点。如果路径名中指定的文件存在于服务器站点，则其内容应由传输的数据替换。如果路径名中指定的文件不存在，则会在服务器站点创建一个新文件。

- `STORE UNIQUE (STOU)`

  ​	此命令的行为类似于`STOR`，只是要在当前目录中以该目录独有的名称创建结果文件（当目录中有这个文件时会创建失败）。回复必须以250开头，并包含生成的文件名字。

- `APPEND (with create) (APPE)`

  ​	此命令使`SERVER-DTP`接受通过数据连接传输的数据，并将数据存储在服务器站点的文件中。如果路径名中指定的文件存在于服务器站点，则应将数据附加到该文件中；否则，应在服务器站点创建路径名中指定的文件。

- `ALLOCATE (ALLO)`

  ​	某些服务器可能需要此命令来保留足够的存储空间，以容纳要传输的新文件。参数应为十进制整数，表示为文件保留的存储字节数（使用逻辑字节大小）。对于使用记录或页面结构发送的文件，可能还需要最大记录或页面大小（以逻辑字节为单位）；这由命令第二个参数字段中的十进制整数表示。第二个参数是可选的，但当存在时，应与第一个参数用三个`Telnet`字符`<SP>R<SP>`分隔。此命令后面应跟着`STORe`或`APPEnd`命令。`ALLO`命令应被那些不需要事先声明文件最大大小的服务器视为`NOOP`（无操作），而那些只对最大记录或页面大小感兴趣的服务器应接受第一个参数中的虚拟值并忽略它。

- `RESTART (REST)`

  ​	参数字段表示重新启动文件传输的服务器标记。此命令不会导致文件传输，但会将文件跳过到指定的数据检查点。此命令后应立即执行相应的`FTP`服务命令，该命令应使文件传输恢复。

- `RENAME FROM (RNFR)`

  ​	此命令指定要重命名的文件的旧路径名。此命令后面必须紧接着一个“重命名为”命令，指定新的文件路径名。

- `RENAME TO (RNTO)`

  ​	此命令指定前一个“重命名自”命令中指定的文件的新路径名。这两个命令一起会导致文件被重命名。

- `ABORT (ABOR)`

  ​	此命令告诉服务器中止上一个`FTP`服务命令和任何相关的数据传输。中止命令可能需要“特殊操作”，如`FTP`命令一节所述，以强制服务器识别。如果前一个命令已完成（包括数据传输），则不采取任何行动。服务器不会关闭控制连接，但必须关闭数据连接。

  > 用来终止数据连接的

  服务器在收到此命令后有两种情况：（1）`FTP`服务命令已完成;（2）`FTP`服务指令仍在执行中。

  - 服务器关闭数据连接（如果它是打开的），并返回226回复，表示中止命令已成功处理。
  - 服务器中止正在进行的`FTP`服务并关闭数据连接，返回426回复，表示服务请求异常终止。然后，服务器发送226回复，指示中止命令已成功处理。

- `DELETE (DELE)`

  ​	此命令会导致在服务器站点上删除路径名中指定的文件。如果需要额外的保护级别（例如查询“您真的要删除吗？”），则应由`USER-FTP`进程提供。

- `REMOVE DIRECTORY (RMD)`

  ​	此命令会将路径名中指定的目录作为目录（如果路径名是绝对的）或当前工作目录的子目录（如果是相对的）删除。见附录二。

- `MAKE DIRECTORY (MKD)`

  ​	此命令将路径名中指定的目录创建为目录（如果路径名是绝对的）或当前工作目录的子目录（如果是相对的）。见附录二。

- `PRINT WORKING DIRECTORY (PWD)`

  ​	此命令会在回复中返回当前工作目录的名称。见附录二。

- `LIST (LIST)`

  ​	此命令使列表从服务器发送到被动`DTP`。如果路径名指定了一个目录或其他文件组，服务器应传输指定目录中的文件列表。如果路径名指定了一个文件，则服务器应发送该文件的当前信息。没有参数表示用户当前的工作目录或默认目录。数据传输是通过`ASCII`或`EBCDIC`类型的数据连接进行的。（用户必须确保`TYPE`是适当的`ASCII`或`EBCDIC`）。由于文件上的信息可能因系统而异，因此这些信息可能很难在程序中自动使用，但对人类用户来说可能非常有用。

- `NAME LIST (NLST)`

  ​	此命令将目录列表从服务器发送到用户站点。路径名应指定目录或其他系统特定的文件组描述符；没有参数表示当前目录。服务器将返回文件名流，而不返回其他信息。数据将以`ASCII`或`EBCDIC`类型通过数据连接传输，作为由`<CRLF>`或`<NL>`分隔的有效路径名字符串。（用户必须再次确保`TYPE`是正确的。）此命令旨在返回程序可用于进一步自动处理文件的信息。例如，在实现“多重获取”函数时。

  > 只返回文件名，而`LIST`不只返回文件名，还会返回文件相关信息

- `SITE PARAMETERS (SITE)`

  ​	服务器使用此命令提供特定于其系统的服务，这些服务对文件传输至关重要，但不足以作为命令包含在协议中。这些服务的性质及其语法规范可以在对HELP SITE命令的回复中说明。

- `SYSTEM (SYST)`

  ​	此命令用于查找服务器上的操作系统类型。回复的第一个单词应为当前版本的编号分配文件[4]中列出的系统名称之一。`TODO:[4]`

- `STATUS (STAT)`

  ​	此命令将导致状态响应以回复的形式通过控制连接发送。该命令可能会在文件传输过程中发送（以及`Telnet IP`和`Synch`信号——请参阅`FTP`命令一节），在这种情况下，服务器将以正在进行的操作状态进行响应，也可能在文件传输之间发送。在后一种情况下，命令可能有一个参数字段。如果参数是路径名，则该命令类似于“`list`”命令，除了数据应通过控制连接传输。如果给出了部分路径名，服务器可能会返回与该规范相关的文件名或属性列表。如果没有给出参数，服务器应返回有关服务器`FTP`进程的一般状态信息。这应该包括所有传输参数的当前值和连接状态。

- `HELP (HELP)`

  ​	此命令应使服务器通过控制连接向用户发送有关其实现状态的有用信息。该命令可以接受一个参数（例如，任何命令名称），并返回更具体的信息作为响应。答案是211或214。建议在输入`USER`命令之前允许使用`HELP`。服务器可以使用此回复来指定与站点相关的参数，例如，响应`HELP SITE`。

- `NOOP (NOOP)`

  ​	此命令不影响任何参数或以前输入的命令。除了服务器发送`OK`回复外，它没有指定任何操作。

​	文件传输协议遵循`Telnet`协议的规范，用于控制连接上的所有通信。由于用于`Telnet`通信的语言可能是协商的选项，因此接下来两节中的所有引用都将是“`Telnet`语言”和相应的“`Telnet`行尾代码”。
目前，人们可能会把这些理解为`NVT-ASCII`和`<CRLF>`。不会引用`Telnet`协议的其他规范。

​	`FTP`命令是以“`Telnet`行尾代码”结尾的“`Telnet`字符串”。命令代码本身是字母字符，如果参数在后面，则以字符`<SP>`（空格）结尾，否则以`Telnet EOL`结尾。本节描述了命令代码和命令语义；命令的详细语法在命令一节中指定，回复序列在命令和回复的排序一节中讨论，典型`FTP`场景一节中提供了说明命令使用的场景。

​	`FTP`命令可以被划分为指定访问控制标识符、数据传输参数或`FTP`服务请求的命令。在数据传输过程中，某些命令（如`ABOR`、`STAT`、`QUIT`）可能会通过控制连接发送。某些服务器可能无法同时监视控制和数据连接，在这种情况下，需要采取一些特殊措施来引起服务器的注意。暂定建议采用以下顺序格式：

1.  用户系统在`Telnet`流中插入"中断进程"信号。
2.  用户系统发送`Telnet`"同步"信号。
3.  用户系统在`Telnet`流中插入命令。
4.  服务器协议解释器在收到"`IP（Interrupt Process）`"信号后，扫描`Telnet`流并提取**唯一一条**`FTP`命令。

（对于其他服务器，这可能不是必需的，但上面列出的操作不应产生异常影响。）

### `FTP`回复（`FTP REPLIES`）

​	对文件传输协议命令的响应旨在确保文件传输过程中请求和操作的同步，并保证用户进程始终知道服务器的状态。每个命令必须至少生成一个回复，尽管可能有多个回复；在后一种情况下，必须很容易区分多个回复。此外，一些命令以顺序组的形式出现，如`USER`、`PASS`和`ACCT`，或`RNFR`和`RNTO`。如果前面的所有命令都成功，则回复显示存在中间状态。序列中任何一点的失败都需要从头开始重复整个序列。

> 命令回复序列的详细信息在下面的一组状态图中明确表示。

​	`FTP`回复由一个三位数（以三个字母数字字符传输）和一些文本组成。该数字旨在供自动机使用，以确定下一步进入什么状态；文本是针对人类用户的。这三个数字包含足够的编码信息，用户进程（`USER-PI`）不需要检查文本，可以酌情丢弃或传递给用户。特别是，文本可能依赖于服务器，因此每个回复代码可能有不同的文本。

​	回复被定义为包含3位代码，后跟空格`<SP>`，后跟一行文本（其中指定了一些最大行长），并以`Telnet`行尾代码终止。然而，有时文本会超过一行。在这些情况下，完整的文本必须放在括号内，这样用户进程就知道什么时候可以停止阅读回复（即停止处理控制连接上的输入），然后去做其他事情。这需要在第一行使用特殊格式来表示多行即将到来，在最后一行使用另一种格式来指定它为最后一行。其中至少有一个必须包含适当的回复代码，以指示事务的状态。为了满足所有派系的要求，决定第一行和最后一行代码应该相同。

​	因此，多行回复的格式是，第一行将以所需的确切回复代码开头，紧接着是“-”（也称为减号），然后是文本。最后一行将以相同的代码开头，紧随其后的是`Space<SP>`、一些文本（可选）和`Telnet`行尾代码。

```
            For example:
                                123-First line
                                Second line
                                  234 A line beginning with numbers
                                123 The last line
```

​	然后，用户进程只需在行首搜索第二次出现的相同回复代码，然后是`<SP>`（空格），并忽略所有中间行。如果中间行以3位数字开头，服务器必须填充前面以避免混淆。

​	该方案允许标准系统例程用于回复信息（如`STAT`回复），并附加“人工”的第一行和最后一行。在极少数情况下，这些例程能够在任何行的开头生成三位数字和空格，每行文本的开头都应该被一些中性文本偏移，如空格。（此方案假设多行回复可能不会嵌套。）

​	回复的三位数字各有特殊意义。这是为了允许用户进程进行一系列非常简单到非常复杂的响应。第一个数字表示响应是好、坏还是不完整。（参考状态图），一个不复杂的用户进程将能够通过简单地检查第一个数字来确定其下一个操作（按计划进行、重做、缩减等）。想要知道大约发生了什么类型的错误（例如文件系统错误、命令语法错误）的用户进程可以检查第二位数字，将第三位数字保留为最精细的信息层次（例如，没有前导`RNFR`的`RNTO`命令）。

​	回复代码的第一位数字有五个值：

- 1yz	初步肯定答复

  ​	正在启动所请求的行动；在继续执行新命令之前，请等待另一个答复。（用户进程在完成回复之前发送另一个命令将违反协议；但`SERVER-FTP`进程应将在执行前一个命令时到达的任何命令排队。）对于难以同时监控的实现，这种类型的回复可用于表示命令已被接受，用户进程现在可以关注数据连接。`SERVER-FTP`进程最多可以发送一个1yz的回复。

- 2yz   积极完成回复 (`Positive Completion reply`)

  ​	请求的操作已成功完成。可能会发起新的请求。

- 3yz   积极的中间回复 Positive Intermediate reply

  ​	该命令已被接受，但请求的操作被搁置，等待收到进一步的信息。用户应发送另一个指定此信息的命令。此回复用于命令序列组。

- 4yz   暂时否定完成回复 Transient Negative Completion reply

  ​	命令未被接受，请求的操作未发生，但错误情况是暂时的，可能会再次请求该操作。用户应返回到命令序列的开头（如果有的话）。很难给“瞬态”赋予含义，特别是当两个不同的站点（服务器和用户进程）必须就解释达成一致时。4yz类别中的每个回复的时间值可能略有不同，但目的是鼓励用户进程重试。确定回复是否符合4yz或5yz（永久否定）类别的一个经验法则是，如果命令可以重复而不改变命令形式或用户或服务器的属性，则回复为4yz（例如，命令的拼写与使用的参数相同；用户不更改其文件访问权限或用户名；服务器不提供新的实现）

- 5yz   永久否定完成回复 Permanent Negative Completion reply

  ​	命令未被接受，请求的操作未发生。不鼓励用户进程重复确切的请求（以相同的顺序）。甚至一些“永久性”错误条件也可以被纠正，因此人类用户可能希望在未来的某个时候（例如，拼写更改后，或用户更改了目录状态后）通过直接操作来指示他的用户进程重新启动命令序列

以下功能分组以第二位数字编码：

- x0z语法-这些回复涉及语法错误、不符合任何功能类别的语法正确命令、未实现或多余的命令。
- x1z信息-这些是对信息请求的回复，如状态或帮助。
- x2z连接-涉及控制和数据连接的回复。
- x3z身份验证和记帐-登录过程和记帐过程的答复。
- x4z尚未指定。
- x5z文件系统-这些回复表示服务器文件系统相对于所请求的传输或其他文件系统操作的状态。

​	第三位数字在第二位数字指定的每个功能类别中给出了更精细的含义层次。下面的答复列表将说明这一点。请注意，与每个回复相关的文本是推荐的，而不是强制性的，甚至可能会根据与之相关的命令而变化。另一方面，回复代码必须严格遵守最后一节中的规范；也就是说，服务器实现不应该为与这里描述的情况略有不同的情况发明新的代码，而应该适应已经定义的代码。

​	`TYPE`或`ALLO`等命令的成功执行不会向用户进程提供任何新信息，这将导致返回200的回复。如果该命令不是由特定的服务器FTP进程实现的，因为它与该计算机系统无关，例如`TOPS20`站点的`ALLO`，则仍然需要肯定完成回复，以便简单的用户进程知道它可以继续其操作过程。在这种情况下，使用202回复，例如回复文本：“不需要存储分配。”另一方面，如果命令请求非特定于站点的操作并且未实现，则响应为502。其改进是对已实现但请求未实现参数的命令的504回复。

#### 按功能组列出的回复代码（`Reply Codes by Function Groups`）

200命令正常。
500语法错误，无法识别命令。这可能包括命令行太长等错误。
501参数或自变量中的语法错误。
202命令未执行，此处多余。
502命令未执行。
503命令顺序错误。
504该参数未执行命令。

110重新启动标记回复。在这种情况下，文本是准确的，而不是留给
具体实施；它必须读取：MARK yyyy=mmmm其中yyyy是用户进程数据流标记，mmmm服务器的等效标记（注意标记和“=”之间的空格）。
211系统状态或系统帮助回复。
212目录状态。
213文件状态。
214帮助信息。关于如何使用服务器或特定非标准命令的含义。此回复仅对人类用户有用。
215 NAME系统类型。其中NAME是Assigned Numbers文档中列表中的官方系统名称。

120服务在nnn分钟内准备就绪。
220服务已为新用户准备就绪。
221服务关闭控制连接。如果合适，请注销。
421服务不可用，正在关闭控制连接。如果服务知道它必须关闭，这可能是对任何命令的回复。
125数据连接已打开；转移开始。
225数据连接打开；没有正在进行的转移。
425无法打开数据连接。
226关闭数据连接。请求的文件操作成功（例如，文件
传输或文件中止）。
426连接已关闭；传输已中止。
227进入被动模式（h1、h2、h3、h4、p1、p2）。

230用户已登录，请继续。
530未登录。
331用户名正常，需要密码。
332需要帐户才能登录。
532需要帐户来存储文件。

150文件状态正常；即将打开数据连接。
250请求的文件操作正常，已完成。
257“路径名”已创建。
350请求的文件操作等待进一步信息。
450请求的文件操作未被执行。文件不可用（例如，文件繁忙）。
550请求的行动未采取。文件不可用（例如，找不到文件，无法访问）。
451请求的操作已中止。处理过程中发生本地错误。
551请求的操作已中止。页面类型未知。
452请求的行动未采取。系统中的存储空间不足。
552请求的文件操作已中止。超出存储分配（针对当前目录或数据集）。
553请求的行动未采取。不允许使用文件名。

#### 回复代码的数字顺序列表（`Numeric  Order List of Reply Codes`）

110重新启动标记回复。在这种情况下，文本是准确的，而不是留给特定的实施；它必须读取：MARK yyyy=mmmm其中yyyy是用户进程数据流标记，mmmm服务器的等效标记（注意标记和“=”之间的空格）。
120服务在nnn分钟内准备就绪。
125数据连接已打开；转移开始。
150文件状态正常；即将打开数据连接。

200命令正常。
202命令未执行，此处多余。
211系统状态或系统帮助回复。
212目录状态。
213文件状态。
214帮助信息。关于如何使用服务器或特定非标准命令的含义。此回复仅对人类用户有用。
215 NAME系统类型。其中NAME是Assigned Numbers文档中列表中的官方系统名称。
220服务已为新用户准备就绪。
221服务关闭控制连接。如果合适，请注销。
225数据连接打开；没有正在进行的转移。
226关闭数据连接。请求的文件操作成功（例如，文件传输或文件中止）。
227进入被动模式（h1、h2、h3、h4、p1、p2）。
230用户已登录，请继续。
250请求的文件操作正常，已完成。
257“路径名”已创建。
331用户名正常，需要密码。
332需要帐户才能登录。
350请求的文件操作等待进一步信息。
421服务不可用，正在关闭控制连接。如果服务知道它必须关闭，这可能是对任何命令的回复。
425无法打开数据连接。
426连接已关闭；传输已中止。
450请求的文件操作未被执行。文件不可用（例如，文件繁忙）。
451请求的操作已中止：处理过程中出现本地错误。
452请求的行动未采取。系统中的存储空间不足。

500语法错误，无法识别命令。
这可能包括命令行太长等错误。
501参数或自变量中的语法错误。
502命令未执行。
503命令顺序错误。
504该参数未执行命令。
530未登录。
532需要帐户来存储文件。
550请求的行动未采取。文件不可用（例如，找不到文件，无法访问）。
551请求的操作中止：页面类型未知。
552请求的文件操作已中止。超出存储分配（针对当前目录或数据集）。
553请求的行动未采取。不允许使用文件名。

## 声明性规范（`DECLARATIVE SPECIFICATIONS`）

### 最小实现（`MINIMUM IMPLEMENTATION`）

​	为了使FTP在没有不必要的错误消息的情况下工作，所有服务器都需要以下最低实现：

- `TYPE`：`ASCII` 非打印

- `MODE`：流模式

- `STRUCTURE`：文件结构，记录结构

- `COMMANDS`：`USER, QUIT, PORT,TYPE, MODE, STRU,RETR, STOR,NOOP.`

  传输参数的默认值为：

  TYPE-ASCII非打印
  MODE-流
  STRU-文件

  所有主机都必须接受上述作为标准默认值。

### 连接（`CONNECTIONS`）

​	服务器协议解释器应“监听”端口L。用户或用户协议解释器应启动全双工控制连接。服务器和用户进程应遵循`ARPA`互联网协议手册[1]中规定的`Telnet`协议约定。服务器没有义务提供命令行的编辑，可能需要在用户主机中完成。在所有传输和回复完成后，服务器应根据用户的请求关闭控制连接。

​	`USER-DTP`必须在指定的数据端口上“监听”；这可能是默认用户端口（U）或`PORT`命令中指定的端口。服务器应使用指定的用户数据端口从其默认数据端口（L-1）启动数据连接。传输方向和使用的端口将由`FTP`服务命令决定。

​	请注意，所有`FTP`实现都必须支持使用默认端口进行数据传输，并且只有`USER-PI`可以启动使用非默认端口。

​	如下图所示，当数据要在两个服务器A和B之间传输时，`USER-PI` C与两个`SERVER-PI`建立控制连接。然后，向其中一个服务器（比如A）发送`PASV`命令，告诉他在收到传输服务命令时“监听”数据端口，而不是启动连接。当`USER-PI`收到对`PASV`命令的确认时，其中包括正在监听的主机和端口的身份，`USER-PI`然后在`PORT`命令中将A的端口A发送给B；则返回回复。然后，`USER-PI`可以向A和B发送相应的服务命令。服务器B发起连接，传输继续进行。下面列出了命令回复序列，其中消息是垂直同步但水平异步的：

```
         User-PI - Server A                User-PI - Server B
         ------------------                ------------------

         C->A : Connect                    C->B : Connect
         C->A : PASV
         A->C : 227 Entering Passive Mode. A1,A2,A3,A4,a1,a2
                                           C->B : PORT A1,A2,A3,A4,a1,a2
                                           B->C : 200 Okay
         C->A : STOR                       C->B : RETR
                    B->A : Connect to HOST-A, PORT-a
```

​	服务器应在“建立数据连接”一节所述的条件下关闭数据连接。如果在数据传输后关闭数据连接，而不需要关闭连接来指示文件结束，则服务器必须立即关闭。不允许等待新的传输命令，因为用户进程已经测试了数据连接，看看是否需要进行“监听”；（请记住，在发送传输请求之前，用户必须在关闭的数据端口上“监听”）。为了防止这里的竞争情况，服务器在关闭数据连接后发送回复（226）（或者如果连接保持打开状态，则发送“文件传输完成”回复（250），`用户PI`应在发出新的传输命令之前等待其中一个回复）。
无论是用户还是服务器，只要发现连接被对方关闭，都应立即读取连接上的任何剩余数据，并在自己这一端发起关闭。
### 命令（`COMMANDS`）

这些命令是通过控制连接传输的 Telnet 字符串，如 `FTP` 命令部分所述。命令的功能和语义在访问控制命令、传输参数命令、`FTP` 服务命令及其他命令部分中进行了描述。命令语法在此处进行了规定。
命令以命令代码开头，后跟一个参数字段。命令代码由四个或更少的字母字符组成。大小写字母应视为相同的。因此，以下任意一个都可以表示检索命令：
```
RETR    Retr    retr    ReTr    rETr
```
这一点同样适用于表示参数值的各类符号，例如`ASCII`类型中的A或a。命令代码与参数字段之间需用一个或多个空格分隔。
参数字段由一个可变长度的字符串组成，该字符串以`<CRLF>`（回车符，换行符）字符序列结束，用于`NVT-ASCII`表示；对于其他协商的语言，可能会使用不同的行结束字符。需要注意的是，在收到行结束代码之前，服务器不会执行任何操作。
语法在NVT-ASCII中指定如下。参数字段中的所有字符均为ASCII字符，包括任何以ASCII表示的十进制整数。方括号表示可选参数字段。若未选择该选项，则默认为相应的默认值。
#### `FTP`命令（`FTP COMMANDS`）
```
USER <SP> <username> <CRLF>
PASS <SP> <password> <CRLF>
ACCT <SP> <account-information> <CRLF>
CWD  <SP> <pathname> <CRLF>
CDUP <CRLF>
SMNT <SP> <pathname> <CRLF>
QUIT <CRLF>
REIN <CRLF>
PORT <SP> <host-port> <CRLF>
PASV <CRLF>
TYPE <SP> <type-code> <CRLF>
STRU <SP> <structure-code> <CRLF>
MODE <SP> <mode-code> <CRLF>
RETR <SP> <pathname> <CRLF>
STOR <SP> <pathname> <CRLF>
STOU <CRLF>
APPE <SP> <pathname> <CRLF>
ALLO <SP> <decimal-integer>
    [<SP> R <SP> <decimal-integer>] <CRLF>
REST <SP> <marker> <CRLF>
RNFR <SP> <pathname> <CRLF>
RNTO <SP> <pathname> <CRLF>
ABOR <CRLF>
DELE <SP> <pathname> <CRLF>
RMD  <SP> <pathname> <CRLF>
MKD  <SP> <pathname> <CRLF>
PWD  <CRLF>
LIST [<SP> <pathname>] <CRLF>
NLST [<SP> <pathname>] <CRLF>
SITE <SP> <string> <CRLF>
SYST <CRLF>
STAT [<SP> <pathname>] <CRLF>
HELP [<SP> <string>] <CRLF>
NOOP <CRLF>
```
#### `FTP`命令参数（`FTP COMMAND ARGUMENTS`）
下列参数字段的语法（在适用的情况下使用巴科斯范式（BNF）表示法）为：
```bnf
The syntax of the above argument fields (using BNF notation
where applicable) is:

  <username> ::= <string>
  <password> ::= <string>
  <account-information> ::= <string>
  <string> ::= <char> | <char><string>
  <char> ::= any of the 128 ASCII characters except <CR> and
  <LF>
  <marker> ::= <pr-string>
  <pr-string> ::= <pr-char> | <pr-char><pr-string>
  <pr-char> ::= printable characters, any
                ASCII code 33 through 126
  <byte-size> ::= <number>
  <host-port> ::= <host-number>,<port-number>
  <host-number> ::= <number>,<number>,<number>,<number>
  <port-number> ::= <number>,<number>
  <number> ::= any decimal integer 1 through 255
  <form-code> ::= N | T | C
  <type-code> ::= A [<sp> <form-code>]
                | E [<sp> <form-code>]
                | I
                | L <sp> <byte-size>
  <structure-code> ::= F | R | P
  <mode-code> ::= S | B | C
  <pathname> ::= <string>
  <decimal-integer> ::= any decimal integer
```
### 命令与回复的排序（`SEQUENCING OF COMMANDS AND REPLIES`）
用户与服务器之间的通信旨在形成一种交互式对话。因此，用户发出FTP命令，服务器则以提示性主回复进行响应。用户应等待此初始主回复表明成功或失败，然后再发送后续命令。
某些命令需要用户等待第二次回复。例如，这些回复可能报告文件传输的进度或完成情况，或者数据连接的关闭情况。它们是针对文件传输命令的二次回复。
一类重要的信息回复是连接问候语。在正常情况下，当连接建立后，服务器会发送一个220的回复，表示“等待输入”。用户应在发送任何命令之前等待这条问候消息。如果服务器无法立即接受输入，应立即发送一个120的“预期延迟”回复，并在准备好时发送一个220的回复。这样，用户就知道如果有延迟，不要挂断电话。
- 自发回复
有时，“系统”会自发地向用户（通常是所有用户）发送信息。例如，“系统将在15分钟后宕机”。`FTP`中并未提供从服务器向用户发送此类自发信息的机制。建议在`SERVER-PI`中将这些信息排队，并在下一次回复中（可能采用多行回复的形式）发送给`USER-PI`。
下表列出了每个命令的备选成功和失败回复。这些回复必须严格遵守；服务器可以在回复中替换文本，但代码数字和特定命令回复序列所暗示的含义和操作不能改变。
- 命令-回复序列
在本节中，将介绍命令-应答序列。每个命令都列出了其可能的应答；命令组则一起列出。首先列出初步应答（其后续应答缩进并置于其下方），然后是肯定和否定完成，最后是中间应答以及序列中剩余的命令。此列表构成了状态图的基础，状态图将另行介绍。

- Connection Establishment
```
    120
      220
    220
    421
```
- Login
```
    USER
      230
      530
      500, 501, 421
      331, 332
    PASS
      230
      202
      530
      500, 501, 503, 421
      332
    ACCT
      230
      202
      530
      500, 501, 503, 421
    CWD
      250
      500, 501, 502, 421, 530, 550
    CDUP
      200
      500, 501, 502, 421, 530, 550
    SMNT
      202, 250
      500, 501, 502, 421, 530, 550
```
- Logout
```
    REIN
      120
          220
      220
      421
      500, 502
    QUIT
      221
      500
```
- Transfer parameters
```
    PORT
      200
      500, 501, 421, 530
    PASV
      227
      500, 501, 502, 421, 530
    MODE
      200
      500, 501, 504, 421, 530
    TYPE
      200
      500, 501, 504, 421, 530
    STRU
      200
      500, 501, 504, 421, 530
```
- File action commands
```
ALLO
  200
  202
  500, 501, 504, 421, 530
REST
  500, 501, 502, 421, 530
  350
STOR
  125, 150
      (110)
      226, 250
      425, 426, 451, 551, 552
  532, 450, 452, 553
  500, 501, 421, 530
STOU
  125, 150
      (110)
      226, 250
      425, 426, 451, 551, 552
  532, 450, 452, 553
  500, 501, 421, 530
RETR
  125, 150
      (110)
      226, 250
      425, 426, 451
  450, 550
  500, 501, 421, 530
LIST
  125, 150
      226, 250
      425, 426, 451
  450
  500, 501, 502, 421, 530
NLST
  125, 150
      226, 250
      425, 426, 451
  450
  500, 501, 502, 421, 530
APPE
  125, 150
      (110)
      226, 250
      425, 426, 451, 551, 552
  532, 450, 550, 452, 553
  500, 501, 502, 421, 530
RNFR
  450, 550
  500, 501, 502, 421, 530
  350
RNTO
  250
  532, 553
  500, 501, 502, 503, 421, 530
DELE
  250
  450, 550
  500, 501, 502, 421, 530
RMD
  250
  500, 501, 502, 421, 530, 550
MKD
  257
  500, 501, 502, 421, 530, 550
PWD
  257
  500, 501, 502, 421, 550
ABOR
  225, 226
  500, 501, 502, 421
```
- Informational commands
```
SYST
  215
  500, 501, 502, 421
STAT
  211, 212, 213
  450
  500, 501, 502, 421, 530
HELP
  211, 214
  500, 501, 502, 421
```
- Miscellaneous commands
```
SITE
  200
  202
  500, 501, 530
NOOP
  200
  500 421
```
## 状态图（`STATE DIAGRAMS`）
这里我们展示了一个非常简单的FTP实现的状态图。仅使用回复代码的第一个数字。每组FTP命令或命令序列都有一个状态图。命令被归纳为各个模型。
对于每个命令或命令序列，都有三种可能的结果：成功（S）、失败（F）和错误（E）。在下面的状态图中，我们用符号B表示“开始”，用符号W表示“等待回复”。
我们首先展示代表最基本的一组FTP命令的图表：
```
                          1,3    +---+
                    ----------->| E |
                    |            +---+
                    |
+---+    cmd    +---+    2      +---+
| B |---------->| W |---------->| S |
+---+           +---+           +---+
                    |
                    |     4,5    +---+
                    ----------->| F |
                                +---+
```
> 以下命令使用的是上述模型：
> `ABOR`, `ALLO`, `DELE`, `CWD`, `CDUP`, `SMNT`, `HELP`, `MODE`, `NOOP`, `PASV`, `QUIT`, `SITE`, `PORT`, `SYST`, `STAT`, `RMD`, `MKD`, `PWD`, `STRU`, 和 `TYPE`.
另一大类命令可以用一个非常相似的图表来表示：
```
                          3      +---+
                    ----------->| E |
                    |            +---+
                    |
+---+    cmd    +---+    2      +---+
| B |---------->| W |---------->| S |
+---+       --->+---+           +---+
            |     | |
            |     | |     4,5    +---+
            |  1  |  ----------->| F |
            -----               +---+
```
> 此图对命令进行了建模：`APPE`、`LIST`、`NLST`、`REIN`、`RETR`、`STOR`和`STOU`。
请注意，这第二个模型也可以用来表示第一组命令，唯一的区别在于，在第一组中，100系列回复是意外的，因此被视为错误，而第二组则期望（有些可能需要）100系列回复。请记住，**每个命令最多只允许有一个100系列回复**。
其余命令的状态模型，其中最简单的是重命名序列：
```
+---+   RNFR    +---+    1,2    +---+
| B |---------->| W |---------->| E |
+---+           +---+        -->+---+
                  | |        |
          3      | | 4,5    |
    --------------  ------   |
  |                      |  |   +---+
  |               ------------->| S |
  |              |   1,3 |  |   +---+
  |             2|  --------
  |              | |     |
  V              | |     |
+---+   RNTO    +---+ 4,5 ----->+---+
|   |---------->| W |---------->| F |
+---+           +---+           +---+
```
下图是重启命令的简单模型：
```
+---+   REST    +---+    1,2    +---+
| B |---------->| W |---------->| E |
+---+           +---+        -->+---+
                  | |        |
          3      | | 4,5    |
    --------------  ------   |
  |                      |  |   +---+
  |               ------------->| S |
  |              |   3   |  |   +---+
  |             2|  --------
  |              | |     |
  V              | |     |
+---+   cmd     +---+ 4,5 ----->+---+
|   |---------->| W |---------->| F |
+---+        -->+---+           +---+
            |      |
            |  1   |
              ------
```
> 这些命令是`APPE`、`STOR`和`RETR`。
我们注意到上述三个模型是相似的。Restart模型与Rename模型的不同之处仅在于第二阶段对100系列回复的处理，而第二组则预期（有些可能需要）100系列回复。请记住，每个命令最多只允许一个100系列回复。
最复杂的图表是登录序列图：
```
                      1
+---+   USER    +---+------------->+---+
| B |---------->| W | 2       ---->| E |
+---+           +---+------  |  -->+---+
                  | |       | | |
                3 | | 4,5   | | |
    --------------   -----  | | |
  |                      | | | |
  |                      | | | |
  |                 ---------  |
  |               1|     | |   |
  V                |     | |   |
+---+   PASS    +---+ 2  |  ------>+---+
|   |---------->| W |------------->| S |
+---+           +---+   ---------->+---+
                  | |   | |     |
                3 | |4,5| |     |
    --------------   --------   |
  |                    | |  |  |
  |                    | |  |  |
  |                 -----------
  |             1,3|   | |  |
  V                |  2| |  |
+---+   ACCT    +---+--  |   ----->+---+
|   |---------->| W | 4,5 -------->| F |
+---+           +---+------------->+---+
```
最后，我们展示了一个通用图示，可用于对命令和回复交互进行建模：
```
          ------------------------------------
        |                                    |
Begin   |                                    |
  |     V                                    |
  |   +---+  cmd   +---+ 2         +---+     |
    -->|   |------->|   |---------->|   |     |
      |   |        | W |           | S |-----|
    -->|   |     -->|   |-----      |   |     |
  |   +---+    |   +---+ 4,5 |     +---+     |
  |     |      |    | |      |               |
  |     |      |   1| |3     |     +---+     |
  |     |      |    | |      |     |   |     |
  |     |       ----  |       ---->| F |-----
  |     |             |            |   |
  |     |             |            +---+
    -------------------
        |
        |
        V
        End
```
## 典型`FTP`场景（`TYPICAL FTP SCENARIO`）
主机U的用户想要与主机S进行文件传输：
通常，用户将通过一个中介用户FTP进程与服务器进行通信。以下可能是一个典型场景。用户FTP提示显示在括号中，“----->”表示从主机U到主机S的命令，“<----”表示从主机S到主机U的回复。
```
LOCAL COMMANDS BY USER              ACTION INVOLVED

ftp (host) multics<CR>         Connect to host S, port L,
                                establishing control connections.
                                <---- 220 Service ready <CRLF>.
username Doe <CR>              USER Doe<CRLF>---->
                                <---- 331 User name ok,
                                          need password<CRLF>.
password mumble <CR>           PASS mumble<CRLF>---->
                                <---- 230 User logged in<CRLF>.
retrieve (local type) ASCII<CR>
(local pathname) test 1 <CR>   User-FTP opens local file in ASCII.
(for. pathname) test.pl1<CR>   RETR test.pl1<CRLF> ---->
                                <---- 150 File status okay;
                                      about to open data
                                      connection<CRLF>.
                                Server makes data connection
                                to port U.

                                <---- 226 Closing data connection,
                                    file transfer successful<CRLF>.
type Image<CR>                 TYPE I<CRLF> ---->
                                <---- 200 Command OK<CRLF>
store (local type) image<CR>
(local pathname) file dump<CR> User-FTP opens local file in Image.
(for.pathname) >udd>cn>fd<CR>  STOR >udd>cn>fd<CRLF> ---->
                                <---- 550 Access denied<CRLF>
terminate                      QUIT <CRLF> ---->
                                Server closes all
                                connections.
```
## 连接建立（`CONNECTION ESTABLISHMENT`）
